<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Todo List Application</title>

  <style>
    /* === CSS Reset === */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    * {
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f5f5;
    }

    /* === Layout === */
    .container {
      max-width: 600px;
      margin: 2rem auto;
      padding: 0 1rem;
    }

    main {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 2rem;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      color: #2c3e50;
      text-align: center;
    }

    /* === Form and Input === */
    .task-form {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .task-form label {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    .task-input {
      flex: 1;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 2px solid #ddd;
      border-radius: 4px;
      transition: border-color 0.2s;
    }

    .task-input:focus {
      outline: none;
      border-color: #3498db;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn-primary {
      background-color: #27ae60;
      color: white;
    }

    .btn-primary:hover {
      background-color: #2980b9;
    }

    /* === Filter Buttons === */
    .filters {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      justify-content: center;
    }

    .filter-btn {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      background-color: #ecf0f1;
      color: #555;
      border: 2px solid transparent;
    }

    .filter-btn:hover {
      background-color: #d5dbdb;
    }

    .filter-btn.active {
      background-color: #3498db;
      color: white;
      border-color: #2980b9;
    }

    /* === Task List === */
    .task-list {
      list-style: none;
    }

    .task-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem;
      border-bottom: 1px solid #eee;
      transition: background-color 0.2s;
    }

    .task-item:hover {
      background-color: #f9f9f9;
    }

    .task-item:last-child {
      border-bottom: none;
    }

    .task-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .task-text {
      flex: 1;
      font-size: 1rem;
      word-break: break-word;
    }

    .task-delete {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
      background-color: #e74c3c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .task-delete:hover {
      background-color: #c0392b;
    }

    /* === Completed Task State === */
    .task-item.completed .task-text {
      text-decoration: line-through;
      opacity: 0.6;
      color: #7f8c8d;
    }

    /* === Accessibility === */
    /* Focus indicators for keyboard navigation */
    .task-input:focus,
    .btn:focus,
    .filter-btn:focus,
    .task-checkbox:focus,
    .task-delete:focus {
      outline: 3px solid #3498db;
      outline-offset: 2px;
    }

    /* Screen reader only text */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    /* Empty state message */
    .empty-state {
      text-align: center;
      padding: 2rem;
      color: #95a5a6;
      font-style: italic;
    }

    /* === Due Date Toolbar === */
    /* Toolbar container for sort and filter controls */
    .toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      margin-bottom: 1rem;
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    /* Sort controls */
    .sort-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .sort-controls label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #555;
    }

    .sort-select {
      padding: 0.5rem;
      font-size: 0.9rem;
      border: 2px solid #ddd;
      border-radius: 4px;
      background-color: white;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    .sort-select:focus {
      outline: none;
      border-color: #3498db;
    }

    /* Filter controls in toolbar */
    .filter-controls {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
    }

    .filter-btn-due {
      padding: 0.4rem 0.75rem;
      font-size: 0.85rem;
      background-color: #ecf0f1;
      color: #555;
      border: 2px solid transparent;
    }

    .filter-btn-due:hover {
      background-color: #d5dbdb;
    }

    .filter-btn-due.active {
      background-color: #3498db;
      color: white;
      border-color: #2980b9;
    }

    /* Priority filter controls */
    .priority-filter-controls {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
    }

    .filter-btn-priority {
      padding: 0.4rem 0.75rem;
      font-size: 0.85rem;
      background-color: #ecf0f1;
      color: #555;
      border: 2px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .filter-btn-priority:hover {
      background-color: #d5dbdb;
    }

    .filter-btn-priority.active {
      background-color: #3498db;
      color: white;
      border-color: #2980b9;
    }

    .filter-btn-priority:focus {
      outline: 3px solid #3498db;
      outline-offset: 2px;
    }

    /* === Due Date Display === */
    /* Styles for displaying due dates next to todo items */
    .due-date {
      font-size: 0.85rem;
      color: #666;
      font-style: italic;
      margin-left: 0.5rem;
    }

    /* === Priority Selection and Display === */
    /* Styles for priority dropdown in creation form and priority badges */

    /* Priority selector dropdown in task creation form */
    .priority-select {
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 2px solid #ddd;
      border-radius: 4px;
      background-color: white;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    .priority-select:focus {
      outline: none;
      border-color: #3498db;
    }

    /* Base styles for priority badges */
    .priority-badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      border-radius: 4px;
      border: 2px solid;
      margin-right: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* High priority badge - red theme */
    .priority-high {
      background-color: #DC2626;
      color: white;
      border-color: #B91C1C;
    }

    /* Medium priority badge - orange theme */
    .priority-medium {
      background-color: #F59E0B;
      color: white;
      border-color: #D97706;
    }

    /* Low priority badge - blue theme */
    .priority-low {
      background-color: #3B82F6;
      color: white;
      border-color: #2563EB;
    }

    /* Muted priority badge for completed tasks */
    .task-item.completed .priority-badge {
      opacity: 0.5;
    }

    /* Priority badge hover and focus states for inline editing */
    .priority-badge:hover {
      opacity: 0.9;
      cursor: pointer;
      transform: scale(1.05);
      transition: all 0.2s;
    }

    .priority-badge:focus {
      outline: 3px solid #3498db;
      outline-offset: 2px;
    }

    /* Inline priority editor container */
    .priority-editor {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      padding: 0.5rem;
      background-color: #f9f9f9;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    .priority-editor select {
      padding: 0.5rem;
      font-size: 0.9rem;
      border: 2px solid #ddd;
      border-radius: 4px;
      transition: border-color 0.2s;
    }

    .priority-editor select:focus {
      outline: none;
      border-color: #3498db;
    }

    /* Edit button for inline due date editing */
    .edit-btn {
      padding: 0.25rem 0.5rem;
      font-size: 1rem;
      background-color: #ecf0f1;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .edit-btn:hover {
      background-color: #d5dbdb;
    }

    /* Inline date picker container */
    .date-picker-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      padding: 0.5rem;
      background-color: #f9f9f9;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    .date-input {
      padding: 0.5rem;
      font-size: 0.9rem;
      border: 2px solid #ddd;
      border-radius: 4px;
      transition: border-color 0.2s;
    }

    .date-input:focus {
      outline: none;
      border-color: #3498db;
    }

    .btn-save,
    .btn-clear {
      padding: 0.5rem 0.75rem;
      font-size: 0.85rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .btn-save {
      background-color: #27ae60;
      color: white;
    }

    .btn-save:hover {
      background-color: #229954;
    }

    .btn-clear {
      background-color: #95a5a6;
      color: white;
    }

    .btn-clear:hover {
      background-color: #7f8c8d;
    }

    /* === Visual Indicators === */
    /* Styles for overdue and due-today visual indicators (color + icons) */

    /* Overdue tasks - red background with red border */
    .task-item.overdue {
      background-color: #fee;
      border-left: 3px solid #c00;
    }

    /* Tasks due today - orange background with orange border */
    .task-item.due-today {
      background-color: #ffedd5;
      border-left: 3px solid #f90;
    }

    /* Status icon styling */
    .status-icon {
      margin-left: 0.25rem;
      font-size: 1rem;
    }

    /* Completed todos with due dates - show indicators at 50% opacity */
    .task-item.completed.overdue,
    .task-item.completed.due-today {
      opacity: 0.6;
    }

    .task-item.completed .status-icon {
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="container">
    <main>
      <h1>My Awesome Tasks</h1>

      <!-- Task Input Form -->
      <form class="task-form" id="taskForm">
        <label for="taskInput">New task</label>
        <input
          type="text"
          id="taskInput"
          class="task-input"
          placeholder="What needs to be done?"
          maxlength="1000"
          autocomplete="off"
        >
        <label for="priority-select" class="sr-only">Priority</label>
        <select id="priority-select" class="priority-select" aria-label="Select priority level">
          <option value="high">High</option>
          <option value="medium" selected>Medium</option>
          <option value="low">Low</option>
        </select>
        <button type="submit" class="btn btn-primary">Add</button>
      </form>

      <!-- Filter Buttons -->
      <div class="filters">
        <button class="btn filter-btn active" data-filter="all">All</button>
        <button class="btn filter-btn" data-filter="active">Active</button>
        <button class="btn filter-btn" data-filter="completed">Completed</button>
      </div>

      <!-- Due Date Toolbar (Sort and Filter) -->
      <div class="toolbar">
        <div class="sort-controls">
          <label for="sort-select">Sort by:</label>
          <select id="sort-select" class="sort-select">
            <option value="none">Default</option>
            <option value="due-asc">Due Date (Earliest First)</option>
            <option value="due-desc">Due Date (Latest First)</option>
          </select>
        </div>
        <div class="filter-controls">
          <button class="btn filter-btn-due active" data-filter-due="all">All</button>
          <button class="btn filter-btn-due" data-filter-due="overdue">Overdue</button>
          <button class="btn filter-btn-due" data-filter-due="today">Due Today</button>
          <button class="btn filter-btn-due" data-filter-due="week">This Week</button>
          <button class="btn filter-btn-due" data-filter-due="none">No Due Date</button>
        </div>
        <div class="priority-filter-controls">
          <button class="btn filter-btn-priority active" data-filter-priority="all" aria-label="Show all priorities">All</button>
          <button class="btn filter-btn-priority" data-filter-priority="high" aria-label="Filter by High priority">High</button>
          <button class="btn filter-btn-priority" data-filter-priority="medium" aria-label="Filter by Medium priority">Medium</button>
          <button class="btn filter-btn-priority" data-filter-priority="low" aria-label="Filter by Low priority">Low</button>
        </div>
      </div>

      <!-- Task List -->
      <ul class="task-list" id="taskList"></ul>

      <!-- ARIA Live Region for screen reader announcements -->
      <div class="sr-only" aria-live="polite" aria-atomic="true" id="announcements"></div>
    </main>
  </div>

  <script>
    // === State Variables ===
    // Array to store all tasks
    let tasks = [];

    // Current filter selection: 'all', 'active', or 'completed'
    let currentFilter = 'all';

    // Current sort selection: 'none', 'due-asc', or 'due-desc'
    let currentSort = 'none';

    // Current due date filter: 'all', 'overdue', 'today', 'week', 'none'
    let currentDueDateFilter = 'all';

    // Current priority filter: 'all', 'high', 'medium', or 'low'
    let currentPriorityFilter = 'all';

    // === Utility Functions ===

    /**
     * Generate a unique ID for a new task
     * Uses timestamp for simplicity and uniqueness in single-user context
     *
     * @returns {number} Unique task ID
     */
    function generateTaskId() {
      return Date.now();
    }

    /**
     * Validate a due date string
     * Checks if the date string is valid ISO 8601 format (YYYY-MM-DD) or null
     *
     * @param {string|null} dueDateString - Date string to validate
     * @returns {boolean} True if valid (or null), false otherwise
     */
    function isValidDueDate(dueDateString) {
      // Null is valid (no due date assigned)
      if (dueDateString === null) {
        return true;
      }

      // Must be a string
      if (typeof dueDateString !== 'string') {
        return false;
      }

      // Check format matches ISO 8601: YYYY-MM-DD
      const isoRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!isoRegex.test(dueDateString)) {
        return false;
      }

      // Parse the date and check if it's valid (not Invalid Date)
      const date = new Date(dueDateString);
      if (isNaN(date.getTime())) {
        return false;
      }

      // Check year is within practical range (2020-2099)
      const year = date.getFullYear();
      if (year < 2020 || year > 2099) {
        return false;
      }

      return true;
    }

    /**
     * Get the status of a due date relative to today
     * Compares the due date to today's date to determine if overdue, due today, or future
     *
     * @param {string|null} dueDateString - ISO 8601 date string (YYYY-MM-DD) or null
     * @returns {string} Status: 'none', 'overdue', 'today', or 'future'
     */
    function getDueDateStatus(dueDateString) {
      // If no due date, return 'none'
      if (!dueDateString) {
        return 'none';
      }

      // Get today's date normalized to midnight (removes time component)
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Parse the due date string (ISO 8601 format: YYYY-MM-DD)
      // Add T00:00:00 to ensure it's parsed as local time at midnight
      const dueDate = new Date(dueDateString + 'T00:00:00');

      // Compare dates to determine status
      if (dueDate < today) {
        return 'overdue';  // Due date is in the past
      }

      if (dueDate.toDateString() === today.toDateString()) {
        return 'today';  // Due date is today
      }

      return 'future';  // Due date is in the future
    }

    /**
     * Validate task text input
     * Checks that text is not empty and within character limit
     *
     * @param {string} text - The task text to validate
     * @returns {boolean} True if valid, false otherwise
     */
    function isValidTaskText(text) {
      // Trim whitespace and check if empty
      const trimmed = text.trim();

      if (trimmed.length === 0) {
        return false; // Empty or whitespace-only
      }

      if (trimmed.length > 1000) {
        return false; // Exceeds maximum length
      }

      return true;
    }

    /**
     * Validate a priority value
     * Checks if the priority string is one of the three valid values
     *
     * @param {string} priority - Priority value to validate
     * @returns {boolean} True if valid, false otherwise
     */
    function isValidPriority(priority) {
      // Must be a string
      if (typeof priority !== 'string') {
        return false;
      }

      // Normalize to lowercase for case-insensitive comparison
      const normalized = priority.toLowerCase();

      // Check if it's one of the three valid values
      return ['high', 'medium', 'low'].includes(normalized);
    }

    /**
     * Get CSS class name for a priority level
     * Maps priority value to corresponding CSS class
     *
     * @param {string} priority - Priority value: 'high', 'medium', or 'low'
     * @returns {string} CSS class name (e.g., 'priority-high')
     */
    function getPriorityClass(priority) {
      // Validate and normalize priority
      if (!isValidPriority(priority)) {
        console.warn('Invalid priority, defaulting to medium:', priority);
        return 'priority-medium';
      }

      // Return class name for the priority level
      const normalized = priority.toLowerCase();
      return `priority-${normalized}`;
    }

    /**
     * Get display label for a priority level
     * Maps priority value to user-friendly label
     *
     * @param {string} priority - Priority value: 'high', 'medium', or 'low'
     * @returns {string} Display label (e.g., 'High', 'Med', 'Low')
     */
    function getPriorityLabel(priority) {
      // Validate and normalize priority
      if (!isValidPriority(priority)) {
        console.warn('Invalid priority, defaulting to medium:', priority);
        return 'Med';
      }

      // Map priority to abbreviated label for space efficiency
      const normalized = priority.toLowerCase();
      if (normalized === 'high') {
        return 'High';
      } else if (normalized === 'medium') {
        return 'Med';
      } else if (normalized === 'low') {
        return 'Low';
      }

      // Fallback (should never reach here due to validation)
      return 'Med';
    }

    /**
     * Get the selected priority from the form dropdown
     * Reads the current selection from the priority dropdown in the task creation form
     *
     * @returns {string} Priority value: 'high', 'medium', or 'low'
     */
    function getPriorityFromForm() {
      // Get the priority select element
      const prioritySelect = document.getElementById('priority-select');

      if (!prioritySelect) {
        console.warn('Priority selector not found, defaulting to medium');
        return 'medium';
      }

      // Get the selected value
      const selectedPriority = prioritySelect.value;

      // Validate the priority value
      if (!isValidPriority(selectedPriority)) {
        console.warn('Invalid priority selected, defaulting to medium:', selectedPriority);
        return 'medium';
      }

      // Return the valid priority
      return selectedPriority.toLowerCase();
    }

    /**
     * Escape HTML characters to prevent XSS attacks
     * Converts special HTML characters to their entity equivalents
     *
     * @param {string} text - Text to escape
     * @returns {string} Escaped text safe for HTML insertion
     */
    function escapeHTML(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Format a due date for user-friendly display
     * Converts ISO 8601 date string to localized readable format
     *
     * @param {string|null} dueDateString - ISO 8601 date string (YYYY-MM-DD) or null
     * @returns {string} Formatted date (e.g., "Oct 14, 2025") or empty string if null
     */
    function formatDueDateForDisplay(dueDateString) {
      // If no due date, return empty string
      if (!dueDateString) {
        return '';
      }

      // Parse the ISO 8601 date string
      const date = new Date(dueDateString + 'T00:00:00');

      // Format using toLocaleDateString with options for readable output
      // Example output: "Oct 14, 2025"
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    }

    /**
     * Announce a message to screen readers via ARIA live region
     * Used for due date changes, sort changes, and filter changes per FR-015
     *
     * @param {string} message - Message to announce (e.g., "Due date set to October 14, 2025")
     * @returns {void}
     */
    function announceToScreenReader(message) {
      // Get the ARIA live region element
      const announcements = document.getElementById('announcements');

      if (!announcements) {
        console.warn('ARIA live region not found');
        return;
      }

      // Set the message text (screen readers will announce it)
      announcements.textContent = message;

      // Clear the message after 1 second so it can be reused for next announcement
      setTimeout(() => {
        announcements.textContent = '';
      }, 1000);
    }

    /**
     * Get icon and ARIA label for a due date status
     * Provides dual-coded indicators (color + icon) for accessibility
     *
     * @param {string} status - Status from getDueDateStatus() ('none', 'overdue', 'today', 'future')
     * @returns {object} {icon: string, label: string, cssClass: string}
     */
    function getDueDateIconAndLabel(status) {
      // Map status to appropriate icon, ARIA label, and CSS class
      if (status === 'overdue') {
        return {
          icon: 'âš ï¸',
          label: 'Warning: Task is overdue',
          cssClass: 'overdue'
        };
      }

      if (status === 'today') {
        return {
          icon: 'ðŸ“…',
          label: 'Due today',
          cssClass: 'due-today'
        };
      }

      // Future or none - no special indicator
      return {
        icon: '',
        label: '',
        cssClass: ''
      };
    }

    // === Storage Functions ===

    /**
     * Save tasks array to localStorage
     * Persists the current tasks array so data survives page refresh
     *
     * @returns {void}
     */
    function saveTasks() {
      try {
        // Convert tasks array to JSON string and save to localStorage
        localStorage.setItem('todoAppTasks', JSON.stringify(tasks));
      } catch (error) {
        // Handle storage quota exceeded error
        if (error.name === 'QuotaExceededError') {
          alert('Storage limit reached. Please delete some tasks to continue.');
        } else {
          console.error('Error saving tasks:', error);
        }
      }
    }

    /**
     * Load tasks from localStorage
     * Retrieves and parses saved tasks, with error handling
     *
     * @returns {Array} Array of task objects, or empty array if none exist
     */
    function loadTasks() {
      try {
        // Get stored tasks from localStorage
        const storedTasks = localStorage.getItem('todoAppTasks');

        // If no stored data, return empty array
        if (!storedTasks) {
          return [];
        }

        // Parse JSON string back to array
        const parsed = JSON.parse(storedTasks);

        // Validate it's an array
        if (!Array.isArray(parsed)) {
          console.warn('Invalid tasks data, starting fresh');
          return [];
        }

        // Validate each task has required properties
        return parsed.filter(task =>
          task.id &&
          typeof task.text === 'string' &&
          typeof task.completed === 'boolean'
        );

      } catch (error) {
        console.error('Error loading tasks:', error);
        return []; // On error, start with empty array
      }
    }

    /**
     * Save current filter selection to localStorage
     * Persists the filter state so it's remembered across sessions
     *
     * @returns {void}
     */
    function saveFilter() {
      try {
        localStorage.setItem('todoAppFilter', currentFilter);
      } catch (error) {
        console.error('Error saving filter:', error);
      }
    }

    /**
     * Load filter selection from localStorage
     * Retrieves the saved filter state, defaults to 'all' if none exists
     *
     * @returns {string} Filter value: 'all', 'active', or 'completed'
     */
    function loadFilter() {
      try {
        const savedFilter = localStorage.getItem('todoAppFilter');
        // Return saved filter if valid, otherwise default to 'all'
        return savedFilter || 'all';
      } catch (error) {
        console.error('Error loading filter:', error);
        return 'all'; // Default to 'all' on error
      }
    }

    /**
     * Migrate todos from schema v1 (feature 001) to schema v2 (feature 002)
     * Adds dueDate: null to any todo missing the field
     * This is a non-destructive, one-time operation that ensures backward compatibility
     *
     * @returns {void}
     */
    function migrateTasksSchema() {
      // Load current tasks from localStorage
      const loadedTasks = loadTasks();

      // Track if any tasks were updated
      let updated = false;

      // Check each task for the dueDate field
      loadedTasks.forEach(task => {
        // If task is missing the dueDate field, add it with null value
        if (!task.hasOwnProperty('dueDate')) {
          task.dueDate = null;
          updated = true;
        }
      });

      // Save back to localStorage only if changes were made
      if (updated) {
        // Update global tasks array
        tasks = loadedTasks;
        saveTasks();
        console.log(`Migration complete: Added dueDate field to ${loadedTasks.length} todos`);
      }
    }

    /**
     * Migrate todos from schema v2 (feature 002) to schema v3 (feature 003)
     * Adds priority: 'medium' to any todo missing the field
     * This is a non-destructive, one-time operation that ensures backward compatibility
     *
     * @returns {void}
     */
    function migratePrioritySchema() {
      // Load current tasks from localStorage
      const loadedTasks = loadTasks();

      // Track if any tasks were updated
      let updated = false;

      // Check each task for the priority field
      loadedTasks.forEach(task => {
        // If task is missing the priority field, add it with 'medium' value
        if (!task.hasOwnProperty('priority')) {
          task.priority = 'medium';
          updated = true;
        }
      });

      // Save back to localStorage only if changes were made
      if (updated) {
        // Update global tasks array
        tasks = loadedTasks;
        saveTasks();
        console.log(`Migration complete: Added priority field to ${loadedTasks.length} todos`);
      }
    }

    /**
     * Check if localStorage is available and working
     * Tests localStorage by attempting to set and remove a test value
     *
     * @returns {boolean} True if localStorage is available, false otherwise
     */
    function isLocalStorageAvailable() {
      try {
        const testKey = '__localStorage_test__';
        localStorage.setItem(testKey, 'test');
        localStorage.removeItem(testKey);
        return true;
      } catch (error) {
        return false;
      }
    }

    // === Rendering Functions ===

    /**
     * Render filter buttons with active state
     * Updates filter button styles to show which filter is active
     *
     * @returns {void}
     */
    function renderFilterButtons() {
      // Get all filter buttons
      const filterButtons = document.querySelectorAll('.filter-btn');

      // Update each button's active state
      filterButtons.forEach(button => {
        const buttonFilter = button.getAttribute('data-filter');

        // Add 'active' class if button matches current filter
        if (buttonFilter === currentFilter) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
    }

    /**
     * Render tasks to the DOM
     * Clears the task list and re-renders all tasks from the tasks array
     *
     * @returns {void}
     */
    function renderTasks() {
      // Get the task list container
      const taskList = document.getElementById('taskList');

      // Clear existing tasks
      taskList.innerHTML = '';

      // Get filtered tasks based on current filter
      const filteredTasks = getFilteredTasks();

      // If no tasks match filter, show empty state
      if (filteredTasks.length === 0) {
        if (tasks.length === 0) {
          taskList.innerHTML = '<li class="empty-state">No tasks yet. Add one above!</li>';
        } else {
          taskList.innerHTML = `<li class="empty-state">No ${currentFilter} tasks.</li>`;
        }
        return;
      }

      // Create and append list items for each filtered task
      filteredTasks.forEach(task => {
        // Calculate due date status for visual indicators
        const dueDateStatus = getDueDateStatus(task.dueDate);
        const statusInfo = getDueDateIconAndLabel(dueDateStatus);

        // Create list item
        const li = document.createElement('li');
        li.className = 'task-item';
        if (task.completed) {
          li.classList.add('completed');
        }
        // Add status CSS class for overdue/today visual indicators
        if (statusInfo.cssClass) {
          li.classList.add(statusInfo.cssClass);
        }

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'task-checkbox';
        checkbox.checked = task.completed;
        checkbox.setAttribute('aria-label', `Mark "${task.text}" as ${task.completed ? 'incomplete' : 'complete'}`);

        // Attach change event listener to toggle completion
        checkbox.addEventListener('change', () => handleCheckboxChange(task.id));

        // Create priority badge (clickable for editing)
        const priorityBadge = document.createElement('span');
        priorityBadge.id = `priority-badge-${task.id}`;
        priorityBadge.className = `priority-badge ${getPriorityClass(task.priority)}`;
        priorityBadge.textContent = getPriorityLabel(task.priority);
        priorityBadge.setAttribute('aria-label', `Priority: ${getPriorityLabel(task.priority)}. Click to edit.`);
        priorityBadge.setAttribute('role', 'button');
        priorityBadge.setAttribute('tabindex', '0');

        // Add click event listener for editing priority
        priorityBadge.addEventListener('click', () => togglePriorityEditor(task.id));

        // Add keyboard support (Enter/Space to open editor)
        priorityBadge.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            togglePriorityEditor(task.id);
          }
        });

        // Create inline priority editor
        const priorityEditor = createPriorityEditor(task.id, task.priority);

        // Create task text span
        const textSpan = document.createElement('span');
        textSpan.className = 'task-text';
        textSpan.textContent = task.text; // Browser automatically escapes text content

        // Display due date if present
        if (task.dueDate) {
          const dueDateSpan = document.createElement('span');
          dueDateSpan.className = 'due-date';
          dueDateSpan.textContent = ` (Due: ${formatDueDateForDisplay(task.dueDate)})`;
          textSpan.appendChild(dueDateSpan);
        }

        // Add status icon for overdue/today tasks (dual-coded with color)
        if (statusInfo.icon) {
          const statusIcon = document.createElement('span');
          statusIcon.className = 'status-icon';
          statusIcon.textContent = ` ${statusInfo.icon}`;
          statusIcon.setAttribute('aria-label', statusInfo.label);
          statusIcon.setAttribute('role', 'img');
          textSpan.appendChild(statusIcon);
        }

        // Create edit icon button
        const editBtn = document.createElement('button');
        editBtn.id = `edit-btn-${task.id}`;
        editBtn.className = 'edit-btn';
        editBtn.innerHTML = 'âœï¸';  // Pencil emoji for edit icon
        editBtn.setAttribute('aria-label', 'Edit due date');
        editBtn.addEventListener('click', () => toggleDatePicker(task.id));

        // Create inline date picker container (hidden by default)
        const datePickerContainer = document.createElement('div');
        datePickerContainer.id = `date-picker-${task.id}`;
        datePickerContainer.className = 'date-picker-container';
        datePickerContainer.style.display = 'none';

        // Create date input
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.id = `date-input-${task.id}`;
        dateInput.className = 'date-input';
        dateInput.value = task.dueDate || '';
        dateInput.setAttribute('aria-label', 'Select due date');

        // Create Save button
        const saveBtn = document.createElement('button');
        saveBtn.className = 'btn-save';
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', (e) => handleDueDateChange(e, task.id, 'save'));

        // Create Clear button
        const clearBtn = document.createElement('button');
        clearBtn.className = 'btn-clear';
        clearBtn.textContent = 'Clear';
        clearBtn.addEventListener('click', (e) => handleDueDateChange(e, task.id, 'clear'));

        // Append inputs to date picker container
        datePickerContainer.appendChild(dateInput);
        datePickerContainer.appendChild(saveBtn);
        datePickerContainer.appendChild(clearBtn);

        // Create delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'task-delete';
        deleteBtn.textContent = 'Delete';
        deleteBtn.setAttribute('aria-label', `Delete task: ${task.text}`);

        // Attach click event listener to delete task
        deleteBtn.addEventListener('click', () => handleDeleteClick(task.id));

        // Append all elements to list item
        li.appendChild(checkbox);
        li.appendChild(priorityBadge);
        li.appendChild(priorityEditor);
        li.appendChild(textSpan);
        li.appendChild(editBtn);
        li.appendChild(datePickerContainer);
        li.appendChild(deleteBtn);

        // Append list item to task list
        taskList.appendChild(li);
      });
    }

    // === Due Date Management Functions ===

    /**
     * Set or update the due date for a todo
     * Validates date format, updates todo, saves, and announces change
     *
     * @param {number} todoId - The ID of the todo to update
     * @param {string} dueDateString - ISO 8601 date string (YYYY-MM-DD)
     * @returns {boolean} True if successful, false if todo not found or invalid date
     */
    function setTodoDueDate(todoId, dueDateString) {
      // Validate date format
      if (!isValidDueDate(dueDateString)) {
        console.warn('Invalid due date format:', dueDateString);
        return false;
      }

      // Find todo by ID
      const todo = tasks.find(t => t.id === todoId);
      if (!todo) {
        console.warn('Todo not found:', todoId);
        return false;
      }

      // Update the due date
      todo.dueDate = dueDateString;

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();

      // Announce change to screen readers
      const formattedDate = formatDueDateForDisplay(dueDateString);
      announceToScreenReader(`Due date set to ${formattedDate}`);

      return true;
    }

    /**
     * Remove the due date from a todo (sets to null)
     * Updates todo, saves, and announces change
     *
     * @param {number} todoId - The ID of the todo to update
     * @returns {boolean} True if successful, false if todo not found
     */
    function removeTodoDueDate(todoId) {
      // Find todo by ID
      const todo = tasks.find(t => t.id === todoId);
      if (!todo) {
        console.warn('Todo not found:', todoId);
        return false;
      }

      // Remove the due date (set to null)
      todo.dueDate = null;

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();

      // Announce change to screen readers
      announceToScreenReader('Due date removed');

      return true;
    }

    /**
     * Toggle visibility of the inline date picker for a todo
     * Shows/hides the date picker and manages focus for accessibility
     *
     * @param {number} todoId - The ID of the todo being edited
     * @returns {void}
     */
    function toggleDatePicker(todoId) {
      // Get the date picker container for this todo
      const pickerContainer = document.getElementById(`date-picker-${todoId}`);
      if (!pickerContainer) {
        console.warn('Date picker container not found for todo:', todoId);
        return;
      }

      // Check if picker is currently hidden
      const isHidden = pickerContainer.style.display === 'none' || pickerContainer.style.display === '';

      if (isHidden) {
        // Show the picker
        pickerContainer.style.display = 'block';

        // Focus the date input for keyboard accessibility
        const dateInput = pickerContainer.querySelector('.date-input');
        if (dateInput) {
          dateInput.focus();
        }
      } else {
        // Hide the picker
        pickerContainer.style.display = 'none';

        // Return focus to the edit button
        const editBtn = document.getElementById(`edit-btn-${todoId}`);
        if (editBtn) {
          editBtn.focus();
        }
      }
    }

    /**
     * Handle date picker value changes
     * Processes save/clear actions and updates todo due date
     *
     * @param {Event} event - The event from save/clear button click
     * @param {number} todoId - ID of the todo being edited
     * @param {string} action - 'save' or 'clear'
     * @returns {void}
     */
    function handleDueDateChange(event, todoId, action) {
      event.preventDefault();

      if (action === 'clear') {
        // Clear the due date
        removeTodoDueDate(todoId);
      } else if (action === 'save') {
        // Get the date input value
        const dateInput = document.getElementById(`date-input-${todoId}`);
        if (!dateInput) {
          return;
        }

        const newDate = dateInput.value;

        if (newDate) {
          // Set the new due date
          setTodoDueDate(todoId, newDate);
        } else {
          // If date input is empty, remove due date
          removeTodoDueDate(todoId);
        }
      }

      // Hide the date picker
      toggleDatePicker(todoId);
    }

    // === Priority Management Functions ===

    /**
     * Set or update the priority for a todo
     * Validates priority value, updates todo, saves, and announces change
     *
     * @param {number} todoId - The ID of the todo to update
     * @param {string} priority - Priority value: 'high', 'medium', or 'low'
     * @returns {boolean} True if successful, false if todo not found or invalid priority
     */
    function setTodoPriority(todoId, priority) {
      // Validate priority value
      if (!isValidPriority(priority)) {
        console.warn('Invalid priority value:', priority);
        return false;
      }

      // Find todo by ID
      const todo = tasks.find(t => t.id === todoId);
      if (!todo) {
        console.warn('Todo not found:', todoId);
        return false;
      }

      // Update the priority
      todo.priority = priority.toLowerCase();

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();

      // Announce change to screen readers
      announceToScreenReader(`Priority changed to ${getPriorityLabel(priority)}`);

      return true;
    }

    /**
     * Toggle visibility of the inline priority editor for a todo
     * Shows/hides the editor and manages focus for accessibility
     *
     * @param {number} todoId - The ID of the todo being edited
     * @returns {void}
     */
    function togglePriorityEditor(todoId) {
      // Get the priority editor container for this todo
      const editorContainer = document.getElementById(`priority-editor-${todoId}`);
      if (!editorContainer) {
        console.warn('Priority editor container not found for todo:', todoId);
        return;
      }

      // Check if editor is currently hidden
      const isHidden = editorContainer.style.display === 'none' || editorContainer.style.display === '';

      if (isHidden) {
        // Show the editor
        editorContainer.style.display = 'block';

        // Focus the priority select for keyboard accessibility
        const prioritySelect = editorContainer.querySelector('select');
        if (prioritySelect) {
          prioritySelect.focus();
        }
      } else {
        // Hide the editor
        editorContainer.style.display = 'none';

        // Return focus to the priority badge
        const priorityBadge = document.getElementById(`priority-badge-${todoId}`);
        if (priorityBadge) {
          priorityBadge.focus();
        }
      }
    }

    /**
     * Create inline priority editor element
     * Builds the editor UI with dropdown and handles priority changes
     *
     * @param {number} todoId - The ID of the todo being edited
     * @param {string} currentPriority - Current priority value
     * @returns {HTMLElement} The editor container element
     */
    function createPriorityEditor(todoId, currentPriority) {
      // Create editor container
      const editorContainer = document.createElement('div');
      editorContainer.id = `priority-editor-${todoId}`;
      editorContainer.className = 'priority-editor';
      editorContainer.style.display = 'none';

      // Create priority select dropdown
      const prioritySelect = document.createElement('select');
      prioritySelect.className = 'priority-select';
      prioritySelect.setAttribute('aria-label', 'Change priority');

      // Add options
      const priorities = ['high', 'medium', 'low'];
      priorities.forEach(priority => {
        const option = document.createElement('option');
        option.value = priority;
        option.textContent = getPriorityLabel(priority);
        if (priority === currentPriority.toLowerCase()) {
          option.selected = true;
        }
        prioritySelect.appendChild(option);
      });

      // Handle priority change
      prioritySelect.addEventListener('change', (e) => {
        const newPriority = e.target.value;
        setTodoPriority(todoId, newPriority);
        togglePriorityEditor(todoId);
      });

      // Add select to container
      editorContainer.appendChild(prioritySelect);

      return editorContainer;
    }

    // === Task Management Functions ===

    /**
     * Add a new task to the list
     * Validates input, creates task object, saves, and re-renders
     *
     * @param {string} taskText - The text content of the task
     * @returns {void}
     */
    // Adds a new task to the list if the input is valid
    function addTask(taskText) {
      // Validate the task text
      if (!isValidTaskText(taskText)) {
        return; // Don't add invalid tasks
      }

      // Create new task object
      const newTask = {
        id: generateTaskId(),
        text: taskText.trim(),
        completed: false,
        dueDate: null,  // ISO 8601 date string (YYYY-MM-DD) or null if no due date
        priority: getPriorityFromForm()  // Get priority from form dropdown
      };

      // Add task to array
      tasks.push(newTask);

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();

      // Announce to screen readers
      const announcements = document.getElementById('announcements');
      announcements.textContent = `Task added: ${newTask.text}`;
    }

    /**
     * Toggle the completion status of a task
     * Finds task by ID and flips its completed property
     *
     * @param {number} taskId - The unique ID of the task to toggle
     * @returns {void}
     */
    function toggleTaskComplete(taskId) {
      // Find the task by ID
      const task = tasks.find(t => t.id === taskId);

      if (!task) {
        return; // Task not found
      }

      // Toggle the completed status
      task.completed = !task.completed;

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();
    }

    /**
     * Delete a task from the list
     * Removes task by ID from the tasks array
     *
     * @param {number} taskId - The unique ID of the task to delete
     * @returns {void}
     */
    function deleteTask(taskId) {
      // Find the index of the task to delete
      const taskIndex = tasks.findIndex(t => t.id === taskId);

      if (taskIndex === -1) {
        return; // Task not found
      }

      // Store task text for announcement
      const deletedTaskText = tasks[taskIndex].text;

      // Remove the task from the array
      tasks.splice(taskIndex, 1);

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();

      // Announce to screen readers
      const announcements = document.getElementById('announcements');
      announcements.textContent = `Task deleted: ${deletedTaskText}`;
    }

    // === Sort and Filter Functions ===

    /**
     * Compare function for sorting todos by due date (ascending)
     * Todos without due dates appear at the end
     *
     * @param {object} todoA - First todo object
     * @param {object} todoB - Second todo object
     * @returns {number} Negative if A < B, positive if A > B, 0 if equal
     */
    function compareDueDates(todoA, todoB) {
      // If both have no due date, maintain original order
      if (!todoA.dueDate && !todoB.dueDate) {
        return 0;
      }

      // Todos without due dates go to the end
      if (!todoA.dueDate) {
        return 1;
      }
      if (!todoB.dueDate) {
        return -1;
      }

      // Compare ISO 8601 strings lexicographically (works because of format)
      return todoA.dueDate.localeCompare(todoB.dueDate);
    }

    /**
     * Sort todos by due date
     * Returns a new sorted array without mutating the original
     *
     * @param {Array} todos - Array of todo objects
     * @param {string} direction - Sort direction: 'asc' (ascending) or 'desc' (descending)
     * @returns {Array} Sorted array
     */
    function sortTodosByDueDate(todos, direction = 'asc') {
      // Create a copy to avoid mutating original array
      const sorted = [...todos];

      // Sort using compareDueDates function
      sorted.sort(compareDueDates);

      // Reverse if descending order
      if (direction === 'desc') {
        sorted.reverse();
      }

      return sorted;
    }

    /**
     * Check if a due date is within the next 7 days (including today)
     *
     * @param {string|null} dueDateString - ISO 8601 date string (YYYY-MM-DD) or null
     * @returns {boolean} True if within next 7 days, false otherwise
     */
    function isWithinNextWeek(dueDateString) {
      // If no due date, return false
      if (!dueDateString) {
        return false;
      }

      // Get today normalized to midnight
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Calculate date 7 days from today
      const nextWeek = new Date(today);
      nextWeek.setDate(today.getDate() + 7);

      // Parse the due date string
      const dueDate = new Date(dueDateString + 'T00:00:00');

      // Check if due date is within the range
      return dueDate >= today && dueDate <= nextWeek;
    }

    /**
     * Filter todos by due date criteria
     *
     * @param {Array} todos - Array of todo objects
     * @param {string} criteria - Filter criteria: 'all', 'overdue', 'today', 'week', 'none'
     * @returns {Array} Filtered array
     */
    function filterTodosByDueDateCriteria(todos, criteria) {
      // If 'all', return copy of all todos
      if (criteria === 'all') {
        return [...todos];
      }

      // Filter by criteria
      if (criteria === 'overdue') {
        return todos.filter(todo => getDueDateStatus(todo.dueDate) === 'overdue');
      }

      if (criteria === 'today') {
        return todos.filter(todo => getDueDateStatus(todo.dueDate) === 'today');
      }

      if (criteria === 'week') {
        return todos.filter(todo => isWithinNextWeek(todo.dueDate));
      }

      if (criteria === 'none') {
        return todos.filter(todo => todo.dueDate === null);
      }

      // Fallback: return all todos
      return [...todos];
    }

    // === Filter Functions ===

    /**
     * Set the current filter and update UI
     * Updates currentFilter state, saves to localStorage, and re-renders
     *
     * @param {string} filter - The filter to apply: 'all', 'active', or 'completed'
     * @returns {void}
     */
    function setFilter(filter) {
      // Validate filter value
      if (!['all', 'active', 'completed'].includes(filter)) {
        console.warn('Invalid filter:', filter);
        return;
      }

      // Update current filter state
      currentFilter = filter;

      // Save filter to localStorage
      saveFilter();

      // Update filter button active states
      renderFilterButtons();

      // Re-render task list with new filter
      renderTasks();
    }

    /**
     * Get filtered and sorted tasks based on current filters and sort
     * Applies completion filter, due date filter, priority filter, and sorting
     *
     * @returns {Array} Filtered and sorted array of task objects
     */
    function getFilteredTasks() {
      let filtered = tasks;

      // Apply completion filter (all/active/completed)
      if (currentFilter === 'active') {
        filtered = filtered.filter(task => !task.completed);
      } else if (currentFilter === 'completed') {
        filtered = filtered.filter(task => task.completed);
      }

      // Apply due date filter (all/overdue/today/week/none)
      filtered = filterTodosByDueDateCriteria(filtered, currentDueDateFilter);

      // Apply priority filter (all/high/medium/low)
      if (currentPriorityFilter !== 'all') {
        filtered = filtered.filter(task => task.priority === currentPriorityFilter);
      }

      // Apply sorting
      if (currentSort === 'due-asc') {
        filtered = sortTodosByDueDate(filtered, 'asc');
      } else if (currentSort === 'due-desc') {
        filtered = sortTodosByDueDate(filtered, 'desc');
      }

      return filtered;
    }

    // === Event Handlers ===

    /**
     * Handle form submission for adding new tasks
     * Prevents default form behavior, validates input, and adds task
     *
     * @param {Event} event - The form submit event
     * @returns {void}
     */
    function handleFormSubmit(event) {
      // Prevent default form submission (page reload)
      event.preventDefault();

      // Get the input element and its value
      const input = document.getElementById('taskInput');
      const taskText = input.value;

      // Add the task if valid
      addTask(taskText);

      // Clear the input field
      input.value = '';

      // Keep focus on input for next task
      input.focus();
    }

    /**
     * Handle checkbox change event for toggling task completion
     * Calls toggleTaskComplete with the task ID
     *
     * @param {number} taskId - The unique ID of the task to toggle
     * @returns {void}
     */
    function handleCheckboxChange(taskId) {
      toggleTaskComplete(taskId);
    }

    /**
     * Handle delete button click event
     * Calls deleteTask with the task ID
     *
     * @param {number} taskId - The unique ID of the task to delete
     * @returns {void}
     */
    function handleDeleteClick(taskId) {
      deleteTask(taskId);
    }

    /**
     * Handle filter button click event
     * Sets the filter based on button's data-filter attribute
     *
     * @param {string} filter - The filter value: 'all', 'active', or 'completed'
     * @returns {void}
     */
    function handleFilterClick(filter) {
      setFilter(filter);
    }

    /**
     * Handle sort dropdown change event
     * Updates sort state and re-renders with sorted results
     *
     * @param {Event} event - Change event from sort dropdown
     * @returns {void}
     */
    function handleSortChange(event) {
      // Get selected sort option
      const sortValue = event.target.value;

      // Update current sort state
      currentSort = sortValue;

      // Save to sessionStorage for FR-012 (session persistence)
      try {
        sessionStorage.setItem('todoAppSort', sortValue);
      } catch (error) {
        console.warn('Could not save sort preference:', error);
      }

      // Re-render with new sort order
      renderTasks();

      // Announce sort change to screen readers
      let message = 'Sort changed to ';
      if (sortValue === 'due-asc') {
        message += 'due date, earliest first';
      } else if (sortValue === 'due-desc') {
        message += 'due date, latest first';
      } else {
        message += 'default order';
      }
      announceToScreenReader(message);
    }

    /**
     * Handle due date filter button click event
     * Updates filter state and re-renders with filtered results
     *
     * @param {Event} event - Click event from filter button
     * @returns {void}
     */
    function handleDueDateFilterClick(event) {
      // Get filter criteria from button's data attribute
      const filterCriteria = event.target.getAttribute('data-filter-due');

      // Update current due date filter state
      currentDueDateFilter = filterCriteria;

      // Save to sessionStorage for FR-012 (session persistence)
      try {
        sessionStorage.setItem('todoAppDueDateFilter', filterCriteria);
      } catch (error) {
        console.warn('Could not save filter preference:', error);
      }

      // Update active button styling
      const filterButtons = document.querySelectorAll('.filter-btn-due');
      filterButtons.forEach(btn => {
        if (btn.getAttribute('data-filter-due') === filterCriteria) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      // Re-render with new filter
      renderTasks();

      // Announce filter change to screen readers
      let message = 'Filter changed to ';
      if (filterCriteria === 'overdue') {
        message += 'overdue tasks only';
      } else if (filterCriteria === 'today') {
        message += 'tasks due today only';
      } else if (filterCriteria === 'week') {
        message += 'tasks due this week only';
      } else if (filterCriteria === 'none') {
        message += 'tasks with no due date only';
      } else {
        message += 'all tasks';
      }
      announceToScreenReader(message);
    }

    /**
     * Handle priority filter button click event
     * Updates filter state and re-renders with filtered results
     *
     * @param {Event} event - Click event from filter button
     * @returns {void}
     */
    function handlePriorityFilterClick(event) {
      // Get filter criteria from button's data attribute
      const filterCriteria = event.target.getAttribute('data-filter-priority');

      // Update current priority filter state
      currentPriorityFilter = filterCriteria;

      // Save to sessionStorage (session persistence like due date filter)
      try {
        sessionStorage.setItem('todoAppPriorityFilter', filterCriteria);
      } catch (error) {
        console.warn('Could not save priority filter preference:', error);
      }

      // Update active button styling
      const filterButtons = document.querySelectorAll('.filter-btn-priority');
      filterButtons.forEach(btn => {
        if (btn.getAttribute('data-filter-priority') === filterCriteria) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      // Re-render with new filter
      renderTasks();

      // Announce filter change to screen readers
      let message = 'Filter changed to ';
      if (filterCriteria === 'high') {
        message += 'high priority tasks only';
      } else if (filterCriteria === 'medium') {
        message += 'medium priority tasks only';
      } else if (filterCriteria === 'low') {
        message += 'low priority tasks only';
      } else {
        message += 'all priorities';
      }
      announceToScreenReader(message);
    }

    // === Initialization ===

    /**
     * Initialize the application
     * Loads saved tasks, sets up event listeners, and renders initial UI
     *
     * @returns {void}
     */
    function init() {
      // Check if localStorage is available
      if (!isLocalStorageAvailable()) {
        alert('Warning: Data will not be saved. Your browser may have disabled storage.');
        // Continue with in-memory mode (app still works, just won't persist)
      }

      // Run migrations to add new fields to existing todos (if needed)
      // These must run before loading tasks into memory
      migrateTasksSchema();      // Schema v1 â†’ v2: adds dueDate field
      migratePrioritySchema();   // Schema v2 â†’ v3: adds priority field

      // Load tasks from localStorage
      tasks = loadTasks();

      // Load filter state from localStorage
      currentFilter = loadFilter();

      // Restore sort, due date filter, and priority filter from sessionStorage
      try {
        const savedSort = sessionStorage.getItem('todoAppSort');
        if (savedSort) {
          currentSort = savedSort;
          document.getElementById('sort-select').value = savedSort;
        }

        const savedDueDateFilter = sessionStorage.getItem('todoAppDueDateFilter');
        if (savedDueDateFilter) {
          currentDueDateFilter = savedDueDateFilter;
        }

        const savedPriorityFilter = sessionStorage.getItem('todoAppPriorityFilter');
        if (savedPriorityFilter) {
          currentPriorityFilter = savedPriorityFilter;
        }
      } catch (error) {
        console.warn('Could not restore session state:', error);
      }

      // Render initial filter button states
      renderFilterButtons();

      // Render initial task list
      renderTasks();

      // Set up form submit event listener
      const form = document.getElementById('taskForm');
      form.addEventListener('submit', handleFormSubmit);

      // Set up completion filter button event listeners
      const filterButtons = document.querySelectorAll('.filter-btn');
      filterButtons.forEach(button => {
        button.addEventListener('click', () => {
          const filter = button.getAttribute('data-filter');
          handleFilterClick(filter);
        });
      });

      // Set up sort dropdown event listener
      const sortSelect = document.getElementById('sort-select');
      if (sortSelect) {
        sortSelect.addEventListener('change', handleSortChange);
      }

      // Set up due date filter button event listeners
      const dueDateFilterButtons = document.querySelectorAll('.filter-btn-due');
      dueDateFilterButtons.forEach(button => {
        button.addEventListener('click', handleDueDateFilterClick);
      });

      // Set up priority filter button event listeners
      const priorityFilterButtons = document.querySelectorAll('.filter-btn-priority');
      priorityFilterButtons.forEach(button => {
        button.addEventListener('click', handlePriorityFilterClick);
      });
    }

    // Wait for DOM to be fully loaded before initializing
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
