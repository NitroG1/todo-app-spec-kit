<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Todo List Application</title>

  <style>
    /* === CSS Reset === */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    * {
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f5f5;
    }

    /* === Layout === */
    .container {
      max-width: 600px;
      margin: 2rem auto;
      padding: 0 1rem;
    }

    main {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 2rem;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      color: #2c3e50;
      text-align: center;
    }

    /* === Form and Input === */
    .task-form {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .task-form label {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    .task-input {
      flex: 1;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border: 2px solid #ddd;
      border-radius: 4px;
      transition: border-color 0.2s;
    }

    .task-input:focus {
      outline: none;
      border-color: #3498db;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn-primary {
      background-color: #27ae60;
      color: white;
    }

    .btn-primary:hover {
      background-color: #2980b9;
    }

    /* === Filter Buttons === */
    .filters {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      justify-content: center;
    }

    .filter-btn {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      background-color: #ecf0f1;
      color: #555;
      border: 2px solid transparent;
    }

    .filter-btn:hover {
      background-color: #d5dbdb;
    }

    .filter-btn.active {
      background-color: #3498db;
      color: white;
      border-color: #2980b9;
    }

    /* === Task List === */
    .task-list {
      list-style: none;
    }

    .task-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem;
      border-bottom: 1px solid #eee;
      transition: background-color 0.2s;
    }

    .task-item:hover {
      background-color: #f9f9f9;
    }

    .task-item:last-child {
      border-bottom: none;
    }

    .task-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .task-text {
      flex: 1;
      font-size: 1rem;
      word-break: break-word;
    }

    .task-delete {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
      background-color: #e74c3c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .task-delete:hover {
      background-color: #c0392b;
    }

    /* === Completed Task State === */
    .task-item.completed .task-text {
      text-decoration: line-through;
      opacity: 0.6;
      color: #7f8c8d;
    }

    /* === Accessibility === */
    /* Focus indicators for keyboard navigation */
    .task-input:focus,
    .btn:focus,
    .filter-btn:focus,
    .task-checkbox:focus,
    .task-delete:focus {
      outline: 3px solid #3498db;
      outline-offset: 2px;
    }

    /* Screen reader only text */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    /* Empty state message */
    .empty-state {
      text-align: center;
      padding: 2rem;
      color: #95a5a6;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="container">
    <main>
      <h1>My Awesome Tasks</h1>

      <!-- Task Input Form -->
      <form class="task-form" id="taskForm">
        <label for="taskInput">New task</label>
        <input
          type="text"
          id="taskInput"
          class="task-input"
          placeholder="What needs to be done?"
          maxlength="1000"
          autocomplete="off"
        >
        <button type="submit" class="btn btn-primary">Add</button>
      </form>

      <!-- Filter Buttons -->
      <div class="filters">
        <button class="btn filter-btn active" data-filter="all">All</button>
        <button class="btn filter-btn" data-filter="active">Active</button>
        <button class="btn filter-btn" data-filter="completed">Completed</button>
      </div>

      <!-- Task List -->
      <ul class="task-list" id="taskList"></ul>

      <!-- ARIA Live Region for screen reader announcements -->
      <div class="sr-only" aria-live="polite" aria-atomic="true" id="announcements"></div>
    </main>
  </div>

  <script>
    // === State Variables ===
    // Array to store all tasks
    let tasks = [];

    // Current filter selection: 'all', 'active', or 'completed'
    let currentFilter = 'all';

    // === Utility Functions ===

    /**
     * Generate a unique ID for a new task
     * Uses timestamp for simplicity and uniqueness in single-user context
     *
     * @returns {number} Unique task ID
     */
    function generateTaskId() {
      return Date.now();
    }

    /**
     * Validate task text input
     * Checks that text is not empty and within character limit
     *
     * @param {string} text - The task text to validate
     * @returns {boolean} True if valid, false otherwise
     */
    function isValidTaskText(text) {
      // Trim whitespace and check if empty
      const trimmed = text.trim();

      if (trimmed.length === 0) {
        return false; // Empty or whitespace-only
      }

      if (trimmed.length > 1000) {
        return false; // Exceeds maximum length
      }

      return true;
    }

    /**
     * Escape HTML characters to prevent XSS attacks
     * Converts special HTML characters to their entity equivalents
     *
     * @param {string} text - Text to escape
     * @returns {string} Escaped text safe for HTML insertion
     */
    function escapeHTML(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // === Storage Functions ===

    /**
     * Save tasks array to localStorage
     * Persists the current tasks array so data survives page refresh
     *
     * @returns {void}
     */
    function saveTasks() {
      try {
        // Convert tasks array to JSON string and save to localStorage
        localStorage.setItem('todoAppTasks', JSON.stringify(tasks));
      } catch (error) {
        // Handle storage quota exceeded error
        if (error.name === 'QuotaExceededError') {
          alert('Storage limit reached. Please delete some tasks to continue.');
        } else {
          console.error('Error saving tasks:', error);
        }
      }
    }

    /**
     * Load tasks from localStorage
     * Retrieves and parses saved tasks, with error handling
     *
     * @returns {Array} Array of task objects, or empty array if none exist
     */
    function loadTasks() {
      try {
        // Get stored tasks from localStorage
        const storedTasks = localStorage.getItem('todoAppTasks');

        // If no stored data, return empty array
        if (!storedTasks) {
          return [];
        }

        // Parse JSON string back to array
        const parsed = JSON.parse(storedTasks);

        // Validate it's an array
        if (!Array.isArray(parsed)) {
          console.warn('Invalid tasks data, starting fresh');
          return [];
        }

        // Validate each task has required properties
        return parsed.filter(task =>
          task.id &&
          typeof task.text === 'string' &&
          typeof task.completed === 'boolean'
        );

      } catch (error) {
        console.error('Error loading tasks:', error);
        return []; // On error, start with empty array
      }
    }

    /**
     * Save current filter selection to localStorage
     * Persists the filter state so it's remembered across sessions
     *
     * @returns {void}
     */
    function saveFilter() {
      try {
        localStorage.setItem('todoAppFilter', currentFilter);
      } catch (error) {
        console.error('Error saving filter:', error);
      }
    }

    /**
     * Load filter selection from localStorage
     * Retrieves the saved filter state, defaults to 'all' if none exists
     *
     * @returns {string} Filter value: 'all', 'active', or 'completed'
     */
    function loadFilter() {
      try {
        const savedFilter = localStorage.getItem('todoAppFilter');
        // Return saved filter if valid, otherwise default to 'all'
        return savedFilter || 'all';
      } catch (error) {
        console.error('Error loading filter:', error);
        return 'all'; // Default to 'all' on error
      }
    }

    /**
     * Check if localStorage is available and working
     * Tests localStorage by attempting to set and remove a test value
     *
     * @returns {boolean} True if localStorage is available, false otherwise
     */
    function isLocalStorageAvailable() {
      try {
        const testKey = '__localStorage_test__';
        localStorage.setItem(testKey, 'test');
        localStorage.removeItem(testKey);
        return true;
      } catch (error) {
        return false;
      }
    }

    // === Rendering Functions ===

    /**
     * Render filter buttons with active state
     * Updates filter button styles to show which filter is active
     *
     * @returns {void}
     */
    function renderFilterButtons() {
      // Get all filter buttons
      const filterButtons = document.querySelectorAll('.filter-btn');

      // Update each button's active state
      filterButtons.forEach(button => {
        const buttonFilter = button.getAttribute('data-filter');

        // Add 'active' class if button matches current filter
        if (buttonFilter === currentFilter) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
    }

    /**
     * Render tasks to the DOM
     * Clears the task list and re-renders all tasks from the tasks array
     *
     * @returns {void}
     */
    function renderTasks() {
      // Get the task list container
      const taskList = document.getElementById('taskList');

      // Clear existing tasks
      taskList.innerHTML = '';

      // Get filtered tasks based on current filter
      const filteredTasks = getFilteredTasks();

      // If no tasks match filter, show empty state
      if (filteredTasks.length === 0) {
        if (tasks.length === 0) {
          taskList.innerHTML = '<li class="empty-state">No tasks yet. Add one above!</li>';
        } else {
          taskList.innerHTML = `<li class="empty-state">No ${currentFilter} tasks.</li>`;
        }
        return;
      }

      // Create and append list items for each filtered task
      filteredTasks.forEach(task => {
        // Create list item
        const li = document.createElement('li');
        li.className = 'task-item';
        if (task.completed) {
          li.classList.add('completed');
        }

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'task-checkbox';
        checkbox.checked = task.completed;
        checkbox.setAttribute('aria-label', `Mark "${task.text}" as ${task.completed ? 'incomplete' : 'complete'}`);

        // Attach change event listener to toggle completion
        checkbox.addEventListener('change', () => handleCheckboxChange(task.id));

        // Create task text span
        const textSpan = document.createElement('span');
        textSpan.className = 'task-text';
        textSpan.textContent = task.text; // Browser automatically escapes text content

        // Create delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'task-delete';
        deleteBtn.textContent = 'Delete';
        deleteBtn.setAttribute('aria-label', `Delete task: ${task.text}`);

        // Attach click event listener to delete task
        deleteBtn.addEventListener('click', () => handleDeleteClick(task.id));

        // Append all elements to list item
        li.appendChild(checkbox);
        li.appendChild(textSpan);
        li.appendChild(deleteBtn);

        // Append list item to task list
        taskList.appendChild(li);
      });
    }

    // === Task Management Functions ===

    /**
     * Add a new task to the list
     * Validates input, creates task object, saves, and re-renders
     *
     * @param {string} taskText - The text content of the task
     * @returns {void}
     */
    // Adds a new task to the list if the input is valid
    function addTask(taskText) {
      // Validate the task text
      if (!isValidTaskText(taskText)) {
        return; // Don't add invalid tasks
      }

      // Create new task object
      const newTask = {
        id: generateTaskId(),
        text: taskText.trim(),
        completed: false
      };

      // Add task to array
      tasks.push(newTask);

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();

      // Announce to screen readers
      const announcements = document.getElementById('announcements');
      announcements.textContent = `Task added: ${newTask.text}`;
    }

    /**
     * Toggle the completion status of a task
     * Finds task by ID and flips its completed property
     *
     * @param {number} taskId - The unique ID of the task to toggle
     * @returns {void}
     */
    function toggleTaskComplete(taskId) {
      // Find the task by ID
      const task = tasks.find(t => t.id === taskId);

      if (!task) {
        return; // Task not found
      }

      // Toggle the completed status
      task.completed = !task.completed;

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();
    }

    /**
     * Delete a task from the list
     * Removes task by ID from the tasks array
     *
     * @param {number} taskId - The unique ID of the task to delete
     * @returns {void}
     */
    function deleteTask(taskId) {
      // Find the index of the task to delete
      const taskIndex = tasks.findIndex(t => t.id === taskId);

      if (taskIndex === -1) {
        return; // Task not found
      }

      // Store task text for announcement
      const deletedTaskText = tasks[taskIndex].text;

      // Remove the task from the array
      tasks.splice(taskIndex, 1);

      // Save to localStorage
      saveTasks();

      // Re-render the task list
      renderTasks();

      // Announce to screen readers
      const announcements = document.getElementById('announcements');
      announcements.textContent = `Task deleted: ${deletedTaskText}`;
    }

    // === Filter Functions ===

    /**
     * Set the current filter and update UI
     * Updates currentFilter state, saves to localStorage, and re-renders
     *
     * @param {string} filter - The filter to apply: 'all', 'active', or 'completed'
     * @returns {void}
     */
    function setFilter(filter) {
      // Validate filter value
      if (!['all', 'active', 'completed'].includes(filter)) {
        console.warn('Invalid filter:', filter);
        return;
      }

      // Update current filter state
      currentFilter = filter;

      // Save filter to localStorage
      saveFilter();

      // Update filter button active states
      renderFilterButtons();

      // Re-render task list with new filter
      renderTasks();
    }

    /**
     * Get filtered tasks based on current filter
     * Returns subset of tasks array matching the current filter
     *
     * @returns {Array} Filtered array of task objects
     */
    function getFilteredTasks() {
      // Return all tasks if filter is 'all'
      if (currentFilter === 'all') {
        return tasks;
      }

      // Return only active (incomplete) tasks
      if (currentFilter === 'active') {
        return tasks.filter(task => !task.completed);
      }

      // Return only completed tasks
      if (currentFilter === 'completed') {
        return tasks.filter(task => task.completed);
      }

      // Fallback: return all tasks
      return tasks;
    }

    // === Event Handlers ===

    /**
     * Handle form submission for adding new tasks
     * Prevents default form behavior, validates input, and adds task
     *
     * @param {Event} event - The form submit event
     * @returns {void}
     */
    function handleFormSubmit(event) {
      // Prevent default form submission (page reload)
      event.preventDefault();

      // Get the input element and its value
      const input = document.getElementById('taskInput');
      const taskText = input.value;

      // Add the task if valid
      addTask(taskText);

      // Clear the input field
      input.value = '';

      // Keep focus on input for next task
      input.focus();
    }

    /**
     * Handle checkbox change event for toggling task completion
     * Calls toggleTaskComplete with the task ID
     *
     * @param {number} taskId - The unique ID of the task to toggle
     * @returns {void}
     */
    function handleCheckboxChange(taskId) {
      toggleTaskComplete(taskId);
    }

    /**
     * Handle delete button click event
     * Calls deleteTask with the task ID
     *
     * @param {number} taskId - The unique ID of the task to delete
     * @returns {void}
     */
    function handleDeleteClick(taskId) {
      deleteTask(taskId);
    }

    /**
     * Handle filter button click event
     * Sets the filter based on button's data-filter attribute
     *
     * @param {string} filter - The filter value: 'all', 'active', or 'completed'
     * @returns {void}
     */
    function handleFilterClick(filter) {
      setFilter(filter);
    }

    // === Initialization ===

    /**
     * Initialize the application
     * Loads saved tasks, sets up event listeners, and renders initial UI
     *
     * @returns {void}
     */
    function init() {
      // Check if localStorage is available
      if (!isLocalStorageAvailable()) {
        alert('Warning: Data will not be saved. Your browser may have disabled storage.');
        // Continue with in-memory mode (app still works, just won't persist)
      }

      // Load tasks from localStorage
      tasks = loadTasks();

      // Load filter state from localStorage
      currentFilter = loadFilter();

      // Render initial filter button states
      renderFilterButtons();

      // Render initial task list
      renderTasks();

      // Set up form submit event listener
      const form = document.getElementById('taskForm');
      form.addEventListener('submit', handleFormSubmit);

      // Set up filter button event listeners
      const filterButtons = document.querySelectorAll('.filter-btn');
      filterButtons.forEach(button => {
        button.addEventListener('click', () => {
          const filter = button.getAttribute('data-filter');
          handleFilterClick(filter);
        });
      });
    }

    // Wait for DOM to be fully loaded before initializing
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
